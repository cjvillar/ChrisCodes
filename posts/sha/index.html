<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SHA, Secure Hash Algorithm 🔒 | CJ_VILLARREAL</title>
<meta name="keywords" content="">
<meta name="description" content="SHA, Secure Hash Algorithm">
<meta name="author" content="Chris">
<link rel="canonical" href="https://canonical.url/to/page">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.cjvillarreal.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.cjvillarreal.com/favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.cjvillarreal.com/favicon.ico">
<link rel="apple-touch-icon" href="https://www.cjvillarreal.com/favicon.ico">
<link rel="mask-icon" href="https://www.cjvillarreal.com/favicon.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.cjvillarreal.com/posts/sha/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-4QBFTL72C3"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-4QBFTL72C3');
        }
      </script>
    
  

<meta property="og:title" content="SHA, Secure Hash Algorithm 🔒" />
<meta property="og:description" content="SHA, Secure Hash Algorithm" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.cjvillarreal.com/posts/sha/" />
<meta property="og:image" content="https://www.cjvillarreal.com/images/sha.gif" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://www.cjvillarreal.com/images/sha.gif" />
<meta name="twitter:title" content="SHA, Secure Hash Algorithm 🔒"/>
<meta name="twitter:description" content="SHA, Secure Hash Algorithm"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.cjvillarreal.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SHA, Secure Hash Algorithm 🔒",
      "item": "https://www.cjvillarreal.com/posts/sha/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SHA, Secure Hash Algorithm 🔒",
  "name": "SHA, Secure Hash Algorithm 🔒",
  "description": "SHA, Secure Hash Algorithm",
  "keywords": [
    
  ],
  "articleBody": "I’ve been thinking a lot about password security and data integrity lately. I remembered learning about hash functions and have used them in past roles for transferring files. I even thought using SHA-256 was standard practice in hashing passwords. This was until I Googled SHA (Secure Hash Algorithm) and learn something. Here’s what I found:\nFirst, what is a SHA (Secure Hash Algorithm)? A secure hash algorithm is a mathematical function that takes input and produces a fixed-size string of characters called a hash value or hash code. The hash value is then used to ensure data integrity and provide a way to identify data uniquely. But How?\nHow it works First, a user provides input data such as text or files they want to hash. The secure hash algorithm applies a series of mathematical operations (via a hash function) to the input data. These operations transform the data into a unique, fixed-length string of alphanumeric characters, regardless of the input’s size. Kind of like a fingerprint to identify the data with.\nWhy it’s cool A secure hash algorithm should produce a unique hash value for each unique input. Even a tiny change in the input data should result in a significantly different hash value. The process of creating a hash value is one directional, meaning it is not possible to derive the original input data from the hash value. Unlike encryption which can be decrypted.\nSecure hash algorithms, such as MD5 (Message Digest Algorithm 5), SHA-1 (Secure Hash Algorithm 1), and SHA-256 (Secure Hash Algorithm 256-bit), are commonly used in various applications, including data integrity checks, password storage, digital signatures, and data verification. They provide a way to verify the integrity and authenticity of data without revealing the original data itself.\nSHA Hash Generator Input text to generate a hash with MD5, SHA-1, and SHA-256.\nEnter Text: Generate Hash Demo: Password Verification When storing passwords, DO NOT store them in plain text. Instead, passwords are typically hashed using a secure hash function. When a user enters their password for authentication, it is hashed and compared against the hash stored in the database to validate their identity without exposing the actual password. Let's mock this out below: Input the same text you did above and see if it gives the correct signature. We're using the hash algorithm (SHA-256)to generate a 256-bit(32 byte) \"signature\" and checking if it matches the same signature you entered above. Note: If you refreshed the browser, generate a new hash. Enter Password: Verify SHA and password hashing SHA algorithms, such as SHA-256, were not designed specifically for password storage. While they are cryptographic hash functions and can be used for password hashing, they have limitations that make them less suitable for this purpose.\nHere are a few reasons why SHA alone is not considered secure for password storage:\nSpeed: SHA algorithms are designed to be fast and efficient, which is desirable for many use cases. However, this speed makes them vulnerable to brute-force and dictionary attacks. Attackers can quickly hash a large number of possible passwords and compare them to the stored hashes, potentially revealing the original passwords.\nLack of Salt: A salt is a random value added to the password before hashing, making each password hash unique. SHA algorithms do not inherently include a salt. Without a salt, attackers can use precomputed tables (rainbow tables) to expedite the process of cracking hashed passwords.\nLack of Iteration/Key Stretching: Iteration or key stretching is the process of applying the hash function multiple times, which significantly slows down the hashing process. This makes it more difficult and time-consuming for attackers to try different password combinations. SHA algorithms do not provide built-in support for iteration or key stretching.\nHow should we store passwords? It’s recommended to use specialized password hashing algorithms designed for secure password storage. Examples of such algorithms include bcrypt , scrypt, and Argon2. These algorithms incorporate features like salting, iteration, and a slower hashing process to make it more difficult and time-consuming for attackers to crack passwords.\nBy using a dedicated password hashing algorithm, you can enhance the security of password storage and protect against common password-related attacks. However, I think the best way to store passwords is not at all! Use something like Google sign-in. Maybe I’ll do a Google deep dive on that too.\n",
  "wordCount" : "720",
  "inLanguage": "en",
  "image":"https://www.cjvillarreal.com/images/sha.gif","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Chris"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.cjvillarreal.com/posts/sha/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CJ_VILLARREAL",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.cjvillarreal.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.cjvillarreal.com/" accesskey="h" title="CJ_VILLARREAL (Alt + H)">CJ_VILLARREAL</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.cjvillarreal.com/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.cjvillarreal.com/">Home</a>&nbsp;»&nbsp;<a href="https://www.cjvillarreal.com/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      SHA, Secure Hash Algorithm 🔒
    </h1>
    <div class="post-description">
      SHA, Secure Hash Algorithm
    </div>
    <div class="post-meta">4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;Chris

</div>
  </header> 
  <div class="post-content"><p>I’ve been thinking a lot about password security and data integrity lately. I remembered learning about hash functions and have used them in past roles for transferring files. I even thought using SHA-256 was standard practice in hashing passwords. This was until I Googled SHA (Secure Hash Algorithm) and learn something. Here’s what I found:</p>
<h2 id="first-what-is-a-sha-secure-hash-algorithm">First, what is a SHA (Secure Hash Algorithm)?<a hidden class="anchor" aria-hidden="true" href="#first-what-is-a-sha-secure-hash-algorithm">#</a></h2>
<p>A secure hash algorithm is a mathematical function that takes input and produces a fixed-size string of characters called a hash value or hash code. The hash value is then used to ensure data integrity and provide a way to identify data uniquely. But How?</p>
<h2 id="how-it-works">How it works<a hidden class="anchor" aria-hidden="true" href="#how-it-works">#</a></h2>
<p>First, a user provides input data such as text or files they want to hash. The secure hash algorithm applies a series of mathematical operations (via a hash function) to the input data. These operations transform the data into a unique, fixed-length string of  alphanumeric characters, regardless of the input&rsquo;s size. Kind of like a fingerprint to identify the data with.</p>
<h2 id="why-its-cool">Why it’s cool<a hidden class="anchor" aria-hidden="true" href="#why-its-cool">#</a></h2>
<p>A secure hash algorithm should produce a unique hash value for each unique input. Even a tiny change in the input data should result in a significantly different hash value. The process of creating a hash value is one directional, meaning it is not possible to derive the original input data from the hash value. Unlike encryption which can be decrypted.</p>
<p>Secure hash algorithms, such as MD5 (Message Digest Algorithm 5), SHA-1 (Secure Hash Algorithm 1), and SHA-256 (Secure Hash Algorithm 256-bit), are commonly used in various applications, including data integrity checks, password storage, digital signatures, and data verification. They provide a way to verify the integrity and authenticity of data without revealing the original data itself.</p>

<html>
<head>
<style>
  form {
    color: #000000;
    max-width: 400px;
    margin: 40px auto;
    padding: 20px;
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  label {
    display: block;
    margin-bottom: 8px;
  }
  
  input[type="password"] {
    width: 100%;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box;
  }
  
  button[type="submit"] {
    display: block;
    width: 100%;
    padding: 10px;
    margin-top: 16px;
    background-color: #000000;
    color: #ffffff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  #text-input {
    color: #000000;
    width: 100%;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-sizing: border-box;
    font-size: 14px;
  }
  #verification-result {
    text-align: center;
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
</head>
<body>
<h1>SHA Hash Generator</h1>
  <p>Input text to generate a hash with MD5, SHA-1, and SHA-256.</p>

<form id="hash-form">
  <label for="text-input">Enter Text:</label>
  <input type="text" id="text-input" required>
  <button type="submit">Generate Hash</button>
</form>
<div id="hash-container"></div>

<h1>Demo: Password Verification</h1>
  <p>
  When storing passwords, <strong>DO NOT</strong> store them in plain text. Instead, passwords are typically hashed using a secure hash function. When a user enters their password for authentication, it is hashed and compared against the hash stored in the database to validate their identity without exposing the actual password.
    <br>
    <br>
  Let's mock this out below: 
  Input the same text you did above and see if it gives the correct signature.
  We're using the hash algorithm (SHA-256)to generate a 256-bit(32 byte) "signature" and checking if it matches the same signature you entered above.
  <br>
  <br>
  <strong>Note: </strong>If you refreshed the browser, generate a new hash.
</p>

<form id="verification-form">
  <label for="password-input">Enter Password:</label>
  <input type="password" id="password-input" required>
  <button type="submit">Verify</button>
</form>
<div id="verification-result"></div>

<script>
   const hashForm = document.getElementById('hash-form');
    const textInput = document.getElementById('text-input');
    const hashContainer = document.getElementById('hash-container');
  
    const verificationForm = document.getElementById('verification-form');
    const passwordInput = document.getElementById('password-input');
    
    let hash = null; // Declare the hash variable outside the event listener
  
    hashForm.addEventListener('submit', event => {
      event.preventDefault();
  
      const text = textInput.value;
  
      // Generate the SHA-256 hash
      hash = CryptoJS.SHA256(text).toString();
      const md5 = CryptoJS.MD5(text).toString();
      const sha1 = CryptoJS.SHA1(text).toString();
      
        
      // Display the hash
      hashContainer.innerHTML = `
        <p><strong>Input Text: </strong><br>${text}</p>
        <p><strong>MD5 Hash: </strong><br>${md5}</p>
        <p><strong>SHA-1 Hash: </strong><br>${sha1}</p>
        <p><strong>SHA-256 Hash: </strong><br>${hash}</p> 
      `;
  
      // Clear the input field
      textInput.value = '';
    });
    
    verificationForm.addEventListener('submit', event => {
      event.preventDefault();
        
      const enteredPassword = passwordInput.value;
  
      // Define the correct password hash
      const correctPasswordHash = hash;
  
      // Generate the SHA-256 hash of the entered password
      const enteredPasswordHash = CryptoJS.SHA256(enteredPassword).toString();
  
      if (enteredPasswordHash === correctPasswordHash) {
        alert('✅ Password is correct! Access granted.');
      } else if (correctPasswordHash === null) {
        alert('🛂 Please Generate a hash.');
      } else {
        alert('❌ Incorrect password. Access denied.');
      } 
      
      // Clear the input field
      passwordInput.value = '';
    });
</script>
</body>
</html>

<h2 id="sha-and-password-hashing">SHA and password hashing<a hidden class="anchor" aria-hidden="true" href="#sha-and-password-hashing">#</a></h2>
<p>SHA algorithms, such as SHA-256, were <strong>not</strong> designed specifically for password storage. While they are cryptographic hash functions and can be used for password hashing, they have limitations that make them less suitable for this purpose.</p>
<p>Here are a few reasons why SHA alone is not considered secure for password storage:</p>
<ol>
<li>
<p><strong>Speed</strong>: SHA algorithms are designed to be fast and efficient, which is desirable for many use cases. However, this speed makes them vulnerable to brute-force and dictionary attacks. Attackers can quickly hash a large number of possible passwords and compare them to the stored hashes, potentially revealing the original passwords.</p>
</li>
<li>
<p><strong>Lack of Salt</strong>: A salt is a random value added to the password before hashing, making each password hash unique. SHA algorithms do not inherently include a salt. Without a salt, attackers can use precomputed tables (rainbow tables) to expedite the process of cracking hashed passwords.</p>
</li>
<li>
<p><strong>Lack of Iteration/Key Stretching</strong>: Iteration or key stretching is the process of applying the hash function multiple times, which significantly slows down the hashing process. This makes it more difficult and time-consuming for attackers to try different password combinations. SHA algorithms do not provide built-in support for iteration or key stretching.</p>
</li>
</ol>
<h2 id="how-should-we-store-passwords">How should we store passwords?<a hidden class="anchor" aria-hidden="true" href="#how-should-we-store-passwords">#</a></h2>
<p>It’s recommended to use specialized password hashing algorithms designed for secure password storage. Examples of such algorithms include <strong>bcrypt</strong> , <strong>scrypt</strong>, and <strong>Argon2</strong>. These algorithms incorporate features like salting, iteration, and a slower hashing process to make it more difficult and time-consuming for attackers to crack passwords.</p>
<p>By using a dedicated password hashing algorithm, you can enhance the security of password storage and protect against common password-related attacks. However, I think the best way to store passwords is not at all! Use something like Google sign-in. Maybe I’ll do a Google deep dive on that too.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.cjvillarreal.com/posts/retrofilmdate/">
    <span class="title">« Prev</span>
    <br>
    <span>Retro Film Date</span>
  </a>
  <a class="next" href="https://www.cjvillarreal.com/posts/basic/">
    <span class="title">Next »</span>
    <br>
    <span>Let’s try something BASIC.</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://www.cjvillarreal.com/">CJ_VILLARREAL</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
